#!/usr/bin/perl

# Requirements
# - various choices to set dsn, user and pass
#   - from environment vars
#   - command line prompt
# - support for client only installation (test database on remote server)

use strict;
use warnings;

use Data::Dumper;
use Carp;

use DBI 1.43;                   # minimum for parse_dsn

sub connect_to_database {

    my $para = tests_init();

    # Connect to the database
    my $dbh = DBI->connect( $para->{tdsn}, $para->{user}, $para->{pass},
        { RaiseError => 1, PrintError => 0, AutoCommit => 1 } );

    return $dbh;
}

sub tests_init {

    my $para = read_cached_configs();

    # Only the record for the isql path is initially found in the
    # 'test.conf' file as generated by Makefile.PL
    my $rec_no = scalar keys %{$para};
    if ( $rec_no == 1 ) {
        print "Init configs\n";
        setup_test_parameters($para);
    }
    elsif ( $rec_no <= 0 ) {
        print "Required config not found, run Makefile.pl && make!\n";
        exit 1;
    }
    else {
        print "Cached configs\n";
    }

    return $para;
}

=head2 setup_test_parameters

Check and read environment parameters, setup required parameters for
the connection.

Create the test database if doesn't exists.

Add the complete DSN to parameters.

Save parameters to 'test.conf' for later use.

=cut

sub setup_test_parameters {
    my $para = shift;

    my $env_vars = check_environment();
    if ( ref $env_vars ) {
        print "Using environment vars ...\n";

        # Merge params hash ref with env_vars
        @{$para}{ keys %{$env_vars} } = values %{$env_vars};
    }
    else {

        # Other way to a aquire user and pass ...
    }

    unless (scalar keys %{$para} > 1) {
        die "Failed to set required parameters!";
    }

    # Format DSN
    $para->{tdsn} = get_dsn( $para );

    my $have_testdb = check_database($para);
    unless ($have_testdb) {
        create_test_database($para);

        # Check again
        die "Failed to create test database!"
          unless $have_testdb = check_database($para);
    }

    save_configs($para);
}

sub get_dsn {
    my $para = shift;

    my $dsn = $para->{tdsn};

    if ($dsn) {
        # Check user provided DSN

        my ( $scheme, $driver, undef, undef, $driver_dsn ) =
            DBI->parse_dsn($dsn)
                or die "Can't parse DBI DSN '$dsn'";

        die "Wrong scheme name: $scheme" if $scheme !~ m{dbi}; # case sensitive?
        die "Wrong driver name: $driver" if $driver ne q(Firebird);
        die "Wrong driver dsn: $driver_dsn" if !$driver_dsn;

        ($para->{path} = $driver_dsn) =~ s{(db(name)?|database)=}{}; # for isql
    }
    else {
        $dsn = make_dsn($para);
    }

    return $dsn;
}

sub make_dsn {
    my $para = shift;

    my $path = '/opt/ibdb/testnew.fdb'; # HARDWIRED !!!
    $para->{path} = $path;      # save it for isql

    return "dbi:Firebird:db=$path";
}

sub find_new_table {
    my $dbh = shift;

    my $try_name = 'TESTAA';
    my $try_name_quoted = $dbh->quote_identifier($try_name);

    my %tables = map { uc($_) => undef } $dbh->tables;

    while (exists $tables{$dbh->quote_identifier($try_name)}) {
        if (++$try_name gt 'TESTZZ') {
            diag("Too many test tables cluttering database ($try_name)\n");
            exit 255;
        }
    }

    return $try_name;
}

=head2 read_cached_configs

Read the connection parameters from the 'test.conf' file.

=cut

sub read_cached_configs {

    my $test_conf = './t/test.conf';
    my $record = {};

    if (-f $test_conf) {
        print "\nReading cached test configuration...\n";

        open my $file_fh, '<', $test_conf
            or croak "Can't open file ", $test_conf, ": $!";

        foreach my $line (<$file_fh>) {
            next if $line =~ m{^#+};         # skip comments

            my ($key, $val) = split /:=/, $line, 2;
            chomp $val;
            $record->{$key} = $val;
        }

        close $file_fh;
    }

    return $record;
}

=head2 save_configs

Append the connection parameters to the 'test.conf' file.

=cut

sub save_configs {
    my $para = shift;

    my $test_conf = './t/test.conf';

    open my $t_fh, '>>', $test_conf or die "Can't write $test_conf: $!";

    my $test_time = scalar localtime();
    my @record = (
        q(### Section 2),
        q(### Time: ) . $test_time,
        qq(tdsn:=$para->{tdsn}),
        qq(user:=$para->{user}),
        qq(pass:=$para->{pass}),
    );
    my $rec = join "\n", @record;

    print {$t_fh} $rec, "\n";

    close $t_fh or die "Can't close $test_conf: $!";

    return;
}

=head2 create_test_database

Create the test database.

=cut

sub create_test_database {
    my $para = shift;

    my ( $isql, $user, $pass, $path ) =
      ( $para->{isql}, $para->{user}, $para->{pass}, $para->{path} );

    #- Create test database

    #-- Create the SQL file with CREATE statement

    open my $t_fh, '>', './t/create.sql'
      or die qq{Can't write to t/create.sql};
    while(<DATA>) {
        s/__TESTDB__/$path/;
        s/__USER__/$user/;
        s/__PASS__/$pass/;
        print {$t_fh} $_;
    }
    close $t_fh;

    #-- Try to execute isql and create the test database

    print 'Create the test database ... ';
    my $ocmd = qq("$isql" -sql_dialect 3 -i ./t/create.sql 2>&1);
    eval {
        # print "cmd is $ocmd\n";
        open my $isql_fh, '-|', $ocmd;
        while (<$isql_fh>) {
            # For debug:
            # print "> $_\n";
        }
        close $isql_fh;
    };
    if ($@) {
        die "ISQL open error!\n";
    }
    else {
        if ( -f $path ) {
            print " done\n";
        }
        else {
            print " failed!\n";
        }
    }

    return;
}

=head2 check_database

Using isql CLI to connect to the database and retrieve the dialect.
If I/O error then conclude that the database doesn't exists.

=cut

sub check_database {
    my $para = shift;

    my ( $isql, $user, $pass, $path ) =
      ( $para->{isql}, $para->{user}, $para->{pass}, $para->{path} );

    #- Connect to the test database

    print "The isql path is $isql\n";
    print "The databse path is $path\n";

    my $dialect;
    my $database_ok = 1;

    my $ocmd = qq("$isql" -u "$user" -p "$pass" -x "$path" 2>&1);
    # print "cmd: $ocmd\n";
    eval {
        open my $fh, '-|', $ocmd;
      LINE:
        while (<$fh>) {
            my $line = $_;
            # Check for I/O error or 'not recognized' ... from cmd.exe
            # print "II $line\n";
            # The systems LANG setting may be a problem ...
            if ($line =~ m{error|recognized}i) {
                $database_ok = 0;
                last LINE;
            }
            # Check for Firebird login errors
            if ($line =~ m{Firebird login}i) {
                print "!!! Check your Firebird login parameters !!!\n";
            }
            # Get dialect if got here
            if ($line =~ m{DIALECT (\d)}i) {
                $dialect = $1;
                last LINE;
            }
        }
        close $fh;
    };
    if ($@) {
        die "isql open error!\n";
    }

    unless ($database_ok) {
        return;
    }

    unless (defined $dialect) {
        print "No dialect?\n";
    }
    else {
        print "Dialect is $dialect\n";
        return $dialect;
    }
}

=head2 check_environment

Check and read environment parameters.

=cut

sub check_environment {

    my $env_record = {};

    #- First check DBI_* environment vars

    # The user can control the test database name and path using
    # DBI_DSN
    $env_record->{tdsn} = $ENV{DBI_DSN} if $ENV{DBI_DSN};

    if ( $ENV{DBI_USER} and $ENV{DBI_PASS} ) {

        # Use only in pairs
        $env_record->{user} = $ENV{DBI_USER};
        $env_record->{pass} = $ENV{DBI_PASS};
    }
    else {

        #- Alternatively, check and use ISC_* environment vars
        if ( $ENV{ISC_USER} and $ENV{ISC_PASSWORD} ) {

            # Use only in pairs
            $env_record->{user} = $ENV{ISC_USER};
            $env_record->{pass} = $ENV{ISC_PASSWORD};
        }
    }

    if ($env_record->{user} and $env_record->{user}) {
        return $env_record;
    }
    else {
        # Not using environment vars
        return;
    }
}

1;

#- The data used to create the database creation script

__DATA__
CREATE DATABASE "__TESTDB__" user "__USER__" password "__PASS__";

quit;
