#!/usr/bin/perl
#
# Helper file for the DBD::Firebird tests
#
# Based on the DBD::InterBase - Makefile.PL script
# (2008-01-08 05:29:19Z by edpratomo)
#
# Inspired by the 't/dbdpg_test_setup.pl' script from DBD::Pg.
#
# 2011-04-01: Created by stefan(s.bv.)
#

use strict;
use warnings;

use Data::Dumper;
use Carp;

use DBI 1.43;                   # minimum version for 'parse_dsn'
use File::Spec;

=head2 connect_to_database

Initialize setting for the connection.

Connect to database and return handler.

=cut

sub connect_to_database {

    my $para = tests_init();

    # Connect to the database
    my $dbh = DBI->connect( $para->{tdsn}, $para->{user}, $para->{pass},
        { RaiseError => 1, PrintError => 0, AutoCommit => 1 } );

    return $dbh;
}

=head2 tests_init

Read the configurations from the L<test.conf> file.

If only the record for the isql path is found in the configuration, as
generated by Makefile.PL, than setup required parameters for the
connection.

If there are more items, only return the parameters hash ref.

=cut

sub tests_init {

    my $para = read_cached_configs();

    my $rec_no = scalar keys %{$para};
    if ( $rec_no == 1 ) {
        print "Initializing configurations.\n";
        setup_test_parameters($para);
    }
    elsif ( $rec_no <= 0 ) {
        print "Required config not found, run Makefile.pl && make!\n";
        exit 1;
    }
    else {
        print "Using cached configuration options.\n";
    }

    return $para;
}

=head2 setup_test_parameters

Check and read environment parameters, setup required parameters for
the connection.

Create the test database if doesn't exists.

Add the complete DSN to parameters.

Save parameters to 'test.conf' for later use.

=cut

sub setup_test_parameters {
    my $para = shift;

    my $env_vars = check_environment();
    if ( ref $env_vars ) {
        print "Using environment vars ...\n";

        # Merge params hash ref with env_vars
        @{$para}{ keys %{$env_vars} } = values %{$env_vars};
    }
    else {

        # Other way to acquire user and pass ...
    }

    unless (scalar keys %{$para} > 1) {
        die "Failed to set required parameters!";
    }

    # Format DSN
    $para->{tdsn} = get_dsn( $para );

    my $have_testdb = check_database($para);
    unless ($have_testdb) {
        create_test_database($para);

        # Check again
        die "Failed to create test database!"
          unless $have_testdb = check_database($para);
    }

    save_configs($para);
}

=head2 get_dsn

Parse and check the DSN, if provided, return a default one if not.

Save the database path for L<isql>.

=cut

sub get_dsn {
    my $para = shift;

    my $dsn = $para->{tdsn};

    if ($dsn) {

        # Check user provided DSN
        my ( $scheme, $driver, undef, undef, $driver_dsn ) =
          DBI->parse_dsn($dsn)
          or die "Can't parse DBI DSN '$dsn'";

        die "Wrong scheme name: $scheme" if $scheme !~ m{dbi}; # case sensitive?
        die "Wrong driver name: $driver" if $driver ne q(Firebird);
        die "Wrong driver dsn: $driver_dsn" if !$driver_dsn;

        ( $para->{path} = $driver_dsn ) =~ s{(db(name)?|database)=}{};
    }
    else {
        $dsn = make_dsn($para);
    }

    return $dsn;
}

=head2 make_dsn

Make a DSN, using a temporary database in the L</tmp> dir for tests as
default.

Save the database path for L<isql>.

=cut

sub make_dsn {
    my $para = shift;

    my $path = catfile(tmpdir(), 'dbd-fb-testdb.fdb');

    $para->{path} = $path;

    return "dbi:Firebird:db=$path";
}

=head2 find_new_table

Find and return a non existent table name between TESTAA and TESTZZ.

=cut

sub find_new_table {
    my $dbh = shift;

    my $try_name = 'TESTAA';
    my $try_name_quoted = $dbh->quote_identifier($try_name);

    my %tables = map { uc($_) => undef } $dbh->tables;

    while (exists $tables{$dbh->quote_identifier($try_name)}) {
        if (++$try_name gt 'TESTZZ') {
            diag("Too many test tables cluttering database ($try_name)\n");
            exit 255;
        }
    }

    return $try_name;
}

=head2 read_cached_configs

Read the connection parameters from the 'test.conf' file.

=cut

sub read_cached_configs {

    my $test_conf = './t/test.conf';
    my $record = {};

    if (-f $test_conf) {
        print "\nReading cached test configuration...\n";

        open my $file_fh, '<', $test_conf
            or croak "Can't open file ", $test_conf, ": $!";

        foreach my $line (<$file_fh>) {
            next if $line =~ m{^#+};         # skip comments

            my ($key, $val) = split /:=/, $line, 2;
            chomp $val;
            $record->{$key} = $val;
        }

        close $file_fh;
    }

    return $record;
}

=head2 save_configs

Append the connection parameters to the 'test.conf' file.

=cut

sub save_configs {
    my $para = shift;

    my $test_conf = './t/test.conf';

    open my $t_fh, '>>', $test_conf or die "Can't write $test_conf: $!";

    my $test_time = scalar localtime();
    my @record = (
        q(# Setup section: - (created by tests-setup.pl) #),
        q(# Time: ) . $test_time,
        qq(tdsn:=$para->{tdsn}),
        qq(user:=$para->{user}),
        qq(pass:=$para->{pass}),
        q(# This is a temporary file used for test setup #),
    );
    my $rec = join "\n", @record;

    print {$t_fh} $rec, "\n";

    close $t_fh or die "Can't close $test_conf: $!";

    return;
}

=head2 create_test_database

Create the test database.

=cut

sub create_test_database {
    my $para = shift;

    my ( $isql, $user, $pass, $path ) =
      ( $para->{isql}, $para->{user}, $para->{pass}, $para->{path} );

    #- Create test database

    #-- Create the SQL file with CREATE statement

    open my $t_fh, '>', './t/create.sql'
      or die qq{Can't write to t/create.sql};
    while(<DATA>) {
        s/__TESTDB__/$path/;
        s/__USER__/$user/;
        s/__PASS__/$pass/;
        print {$t_fh} $_;
    }
    close $t_fh;

    #-- Try to execute isql and create the test database

    print 'Create the test database ... ';
    my $ocmd = qq("$isql" -sql_dialect 3 -i ./t/create.sql 2>&1);
    eval {
        # print "cmd is $ocmd\n";
        open my $isql_fh, '-|', $ocmd;
        while (<$isql_fh>) {
            # For debug:
            # print "> $_\n";
        }
        close $isql_fh;
    };
    if ($@) {
        die "ISQL open error!\n";
    }
    else {
        if ( -f $path ) {
            print " done\n";
        }
        else {
            print " failed!\n";
        }
    }

    return;
}

=head2 check_database

Using isql CLI to connect to the database and retrieve the dialect.
If I/O error then conclude that the database doesn't exists.

=cut

sub check_database {
    my $para = shift;

    my ( $isql, $user, $pass, $path ) =
      ( $para->{isql}, $para->{user}, $para->{pass}, $para->{path} );

    #- Connect to the test database

    print "The isql path is $isql\n";
    print "The databse path is $path\n";

    my $dialect;
    my $database_ok = 1;

    my $ocmd = qq("$isql" -u "$user" -p "$pass" -x "$path" 2>&1);
    # print "cmd: $ocmd\n";
    eval {
        open my $fh, '-|', $ocmd;
      LINE:
        while (<$fh>) {
            my $line = $_;
            # Check for I/O error or 'not recognized' ... from cmd.exe
            # print "II $line\n";
            # The systems LANG setting may be a problem ...
            if ($line =~ m{error|recognized}i) {
                $database_ok = 0;
                last LINE;
            }
            # Check for Firebird login errors
            if ($line =~ m{Firebird login}i) {
                print "!!! Check your Firebird login parameters !!!\n";
            }
            # Get dialect if got here
            if ($line =~ m{DIALECT (\d)}i) {
                $dialect = $1;
                last LINE;
            }
        }
        close $fh;
    };
    if ($@) {
        die "isql open error!\n";
    }

    unless ($database_ok) {
        return;
    }

    unless (defined $dialect) {
        print "No dialect?\n";
    }
    else {
        print "Dialect is $dialect\n";
        return $dialect;
    }
}

=head2 check_environment

Check and read environment parameters.

=cut

sub check_environment {

    my $env_record = {};

    #- First check DBI_* environment vars

    # The user can control the test database name and path using
    # DBI_DSN
    $env_record->{tdsn} = $ENV{DBI_DSN} if $ENV{DBI_DSN};

    if ( $ENV{DBI_USER} and $ENV{DBI_PASS} ) {

        # Use only in pairs
        $env_record->{user} = $ENV{DBI_USER};
        $env_record->{pass} = $ENV{DBI_PASS};
    }
    else {

        #- Alternatively, check and use ISC_* environment vars
        if ( $ENV{ISC_USER} and $ENV{ISC_PASSWORD} ) {

            # Use only in pairs
            $env_record->{user} = $ENV{ISC_USER};
            $env_record->{pass} = $ENV{ISC_PASSWORD};
        }
    }

    if ($env_record->{user} and $env_record->{user}) {
        return $env_record;
    }
    else {
        # Not using environment vars
        return;
    }
}

1;

#- The data used to create the database creation script

__DATA__
CREATE DATABASE "__TESTDB__" user "__USER__" password "__PASS__";

quit;
